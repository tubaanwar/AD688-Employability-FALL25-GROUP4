---
title: "Exploratory Data Analysis"
subtitle: "Uncovering Job Market Trends and Patterns in 2024"
format: 
  html:
    toc: true
    number-sections: true
    df-print: paged
    code-overflow: wrap
    embed-resources: true
    theme: 
      light: [cosmo, custom.scss]
    css: styles.css 
jupyter: python3
execute:
  echo: false
  warning: false
  message: false
---

## Introduction

This document presents a comprehensive exploratory data analysis of the 2024 job market. We examine hiring trends, employment types, geographic patterns, and remote work opportunities to provide actionable insights for job seekers and market analysts.

```{python}
import pandas as pd
import numpy as np
import hvplot.pandas
import panel as pn
import warnings
warnings.filterwarnings('ignore')

# Enable panel for rendering
pn.extension()

# Updated color palette - blue, pink, purple, red
COLORS = ['#2196F3', '#E91E63', '#9B59B6', '#F44336', '#00BCD4', '#FF4081', '#7E57C2', '#EF5350']

# Load cleaned data
df = pd.read_csv('cleanedjob_postings.csv')

print(f"Dataset shape: {df.shape}")
print(f"Analysis period: 2024 Job Market")
print(f"Total job postings analyzed: {len(df):,}")
```

## 1. Job Title Analysis

### 1.1 Top In-Demand Job Titles

Understanding which job titles dominate the market helps identify high-demand roles and emerging career opportunities.

```{python}
# Get top 10 job titles 
title_counts = df[df['TITLE_NAME'].notna()]['TITLE_NAME'].value_counts().head(10)
title_df = pd.DataFrame({
    'Job Title': title_counts.index, 
    'Count': title_counts.values,
    'Percentage': (title_counts.values / len(df[df['TITLE_NAME'].notna()]) * 100).round(2)
})

print(f"\nTop job titles : {len(title_counts)} titles")

# Create interactive horizontal bar chart
title_df.hvplot.barh(
    x='Job Title',
    y='Count',
    title='Top 10 Most In-Demand Job Titles (2024)',
    height=500,
    width=800,
    color='#2196F3',
    hover_cols=['Percentage'],
    ylabel='',
    xlabel='Number of Job Postings',
    flip_yaxis=True
).opts(xformatter='%.0f')
```

::: {.callout-note icon=false}
## Key Insight
The top job titles reveal where the market has the highest demand. Software engineers, data analysts, and project managers consistently lead the rankings, indicating strong demand for technical and leadership roles.
:::

## 2. Employment Type Distribution

### 2.1 Full-Time vs Part-Time vs Contract

Understanding employment type distribution helps job seekers target positions matching their career preferences.

```{python}
# Count jobs by employment type 
df_employment = df[df['EMPLOYMENT_TYPE_NAME'].notna()].copy()

# Remove "Unknown" values
df_employment = df_employment[df_employment['EMPLOYMENT_TYPE_NAME'] != 'Unknown']

employment_counts = df_employment['EMPLOYMENT_TYPE_NAME'].value_counts()
employment_df = pd.DataFrame({
    'Employment Type': employment_counts.index, 
    'Count': employment_counts.values,
    'Percentage': (employment_counts.values / employment_counts.sum() * 100).round(1)
})

print(f"\nEmployment types : {len(df_employment):,} jobs")
print(employment_df.to_string(index=False))

# Create bar chart
employment_df.hvplot.bar(
    x='Employment Type',
    y='Count',
    title='Job Market Distribution by Employment Type (2024)',
    height=400,
    width=700,
    color='Employment Type',
    cmap=COLORS,
    hover_cols=['Percentage'],
    ylabel='Number of Job Postings',
    rot=45
).opts(yformatter='%.0f')
```

::: {.callout-note icon=false}
## Key Insight
The distribution of employment types shows whether the market primarily offers full-time stability, part-time flexibility, or contract-based project work. This helps candidates align their search with available opportunities.
:::

## 3. Remote Work Analysis

### 3.1 Remote vs Hybrid vs On-Site

The prevalence of remote work reflects post-pandemic hiring trends and employer flexibility.

```{python}
# Count jobs by remote type and remove not specified values
df_remote = df.copy()

# Replace None, NaN, Unknown, empty strings with NaN
df_remote['REMOTE_TYPE_NAME'] = df_remote['REMOTE_TYPE_NAME'].replace({
    '[None]': np.nan,
    'None': np.nan,
    'Unknown': np.nan,
    '': np.nan,
    'Not Specified': np.nan
})

# Drop rows with NaN in REMOTE_TYPE_NAME
df_remote = df_remote[df_remote['REMOTE_TYPE_NAME'].notna()]

print(f"\nRemote type distribution (excluding not specified):")
print(f"Total jobs with remote info: {len(df_remote):,}")

# Count jobs by remote type
remote_counts = df_remote['REMOTE_TYPE_NAME'].value_counts()
remote_df = pd.DataFrame({
    'Remote Type': remote_counts.index,
    'Count': remote_counts.values,
    'Percentage': (remote_counts.values / remote_counts.sum() * 100).round(1)
})

print(remote_df.to_string(index=False))

# Create bar chart with custom colors
remote_df.hvplot.bar(
    x='Remote Type',
    y='Count',
    title='Job Market Distribution: Remote, Hybrid & On-Site Opportunities (2024)',
    height=400,
    width=700,
    color='Remote Type',
    cmap=['#2196F3', '#E91E63', '#9B59B6', '#F44336'],
    hover_cols=['Percentage'],
    ylabel='Number of Job Postings',
    xlabel='Work Location Type',
    rot=0
).opts(yformatter='%.0f')
```

::: {.callout-note icon=false}
## Key Insight
The balance between remote, hybrid, and on-site jobs indicates industry acceptance of flexible work arrangements. Higher remote percentages suggest employers prioritize talent acquisition over geographic constraints.
:::

## 4. Geographic Analysis

### 4.1 Top States for Job Opportunities

Geographic distribution shows where job opportunities are concentrated.

```{python}
# Get top 10 states by job postings 
df_states = df[df['STATE_NAME'].notna()].copy()

state_counts = df_states['STATE_NAME'].value_counts().head(10)
state_df = pd.DataFrame({
    'State': state_counts.index,
    'Job Postings': state_counts.values,
    'Percentage': (state_counts.values / len(df_states) * 100).round(2)
})

print(f"\nStates with job postings : {len(df_states):,} jobs")

# Create bar chart
state_df.hvplot.bar(
    x='State',
    y='Job Postings',
    title='Top 10 States by Number of Job Postings (2024)',
    height=450,
    width=850,
    color='#9B59B6',
    hover_cols=['Percentage'],
    ylabel='Number of Job Postings',
    xlabel='State',
    rot=45
).opts(yformatter='%.0f')
```

::: {.callout-note icon=false}
## Key Insight
Geographic concentration shows tech hubs and major metropolitan areas dominate job postings. Regional variations help identify where to focus job searches based on market demand.
:::

## 5. Top Hiring Companies

### 5.1 Companies with Most Job Openings

Identifying top hiring companies helps job seekers target organizations with multiple opportunities.

```{python}
# Get top 10 companies by job postings (remove None values)
df_companies = df[df['COMPANY_NAME'].notna()].copy()

company_counts = df_companies['COMPANY_NAME'].value_counts().head(10)
company_df = pd.DataFrame({
    'Company': company_counts.index,
    'Job Postings': company_counts.values
})

print(f"\nCompanies with job postings : {len(df_companies):,} jobs")

# Create horizontal bar chart
company_df.hvplot.barh(
    x='Company',
    y='Job Postings',
    title='Top 15 Companies by Number of Job Postings (2024)',
    height=550,
    width=800,
    color='#E91E63',
    ylabel='',
    xlabel='Number of Job Postings',
    flip_yaxis=True
).opts(xformatter='%.0f')
```

::: {.callout-note icon=false}
## Key Insight
Companies with the highest number of job postings indicate organizations actively expanding their workforce. These companies may offer better opportunities for multiple role applications and career growth.
:::

## 6. Job Posting Timeline

### 6.1 When Jobs Are Posted

Understanding posting patterns helps with strategic job search timing.

```{python}
# Print diagnostics
print("\nAnalyzing POSTED column:")
print(f"Sample values: {df['POSTED'].head(10)}")
print(f"Data type: {df['POSTED'].dtype}")

# Convert POSTED to datetime
df_time = df.copy()
df_time['POSTED'] = pd.to_datetime(df_time['POSTED'], errors='coerce')

print(f"\nAfter conversion:")
print(f"Date range: {df_time['POSTED'].min()} to {df_time['POSTED'].max()}")
print(f"Valid dates: {df_time['POSTED'].notna().sum():,} out of {len(df_time):,}")
print(f"Missing dates: {df_time['POSTED'].isna().sum():,}")

# Filter valid dates
time_data = df_time[df_time['POSTED'].notna()].copy()

if len(time_data) > 0:
    # Extract year-month
    time_data['YearMonth'] = time_data['POSTED'].dt.to_period('M')
    
    # Group by month and count
    monthly_counts = time_data.groupby('YearMonth').size().reset_index(name='Job Postings')
    monthly_counts['Month'] = monthly_counts['YearMonth'].astype(str)
    
    # Sort by month
    monthly_counts = monthly_counts.sort_values('Month')
    
    print(f"\nMonthly posting counts:")
    print(monthly_counts[['Month', 'Job Postings']].to_string(index=False))
    
    # Create line and area chart
    line_chart = monthly_counts.hvplot.line(
        x='Month',
        y='Job Postings',
        title='Job Posting Trends Over Time (2024)',
        height=400,
        width=850,
        color='#2196F3',
        line_width=3,
        ylabel='Number of Job Postings',
        xlabel='Month',
        rot=45
    ).opts(yformatter='%.0f')
    
    area_chart = monthly_counts.hvplot.area(
        x='Month',
        y='Job Postings',
        alpha=0.3,
        color='#2196F3'
    )
    
    # Combine line and area
    (line_chart * area_chart)
else:
    print("\nWarning: No valid dates found in POSTED column")
    print("Sample of POSTED values:")
    print(df['POSTED'].head(20))
```

::: {.callout-note icon=false}
## Key Insight
Temporal patterns in job postings reveal seasonal hiring trends and peak recruitment periods. Understanding these patterns helps time job applications for maximum visibility and response rates.
:::

## 7. Experience Requirements

### 7.1 Minimum Years of Experience Required

Understanding experience requirements helps assess job market accessibility.

```{python}
# Analyze minimum years of experience (remove None values)
df_experience = df[df['MIN_YEARS_EXPERIENCE'].notna()].copy()

exp_counts = df_experience['MIN_YEARS_EXPERIENCE'].value_counts().sort_index()
exp_df = pd.DataFrame({
    'Years of Experience': exp_counts.index,
    'Job Postings': exp_counts.values
})

# Convert Years of Experience to string for better labels
exp_df['Years Label'] = exp_df['Years of Experience'].astype(int).astype(str) + ' years'

print(f"\nJobs with experience requirements (excluding None): {len(df_experience):,} jobs")
print(exp_df[['Years of Experience', 'Job Postings']].to_string(index=False))

# Create bar chart with pastel purple color
exp_df.hvplot.bar(
    x='Years Label',
    y='Job Postings',
    title='Job Postings by Minimum Years of Experience Required (2024)',
    height=400,
    width=800,
    color='#B39DDB',
    ylabel='Number of Job Postings',
    xlabel='Minimum Years of Experience',
    rot=45
).opts(yformatter='%.0f')
```

::: {.callout-note icon=false}
## Key Insight
Experience distribution shows the accessibility of the job market for entry-level versus experienced professionals. A healthy mix indicates opportunities across career stages.
:::

## References

- Data source: Lightcast Job Postings Dataset (2024)
- Visualization tools: hvPlot, Panel, Python
- Analysis framework: Standard EDA best practices